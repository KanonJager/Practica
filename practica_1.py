# -*- coding: utf-8 -*-
"""Practica 1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CMueEfV3eYjRMxTzyGoVhH7GTLB62mok
"""

import pandas as pd
import numpy as np
import missingno as msno

path = 'agro.csv'
df = pd.read_csv(path, encoding='latin', error_bad_lines=False)
df.head()

#General Status
df.info()

#Shape of dataframe
df.shape

#Number of rows
df.shape[0]

#Number of columns
df.shape[1]

#Column Names
df.columns.values.tolist()

#Column Data Types
df.dtypes

# Are there missing values?

df.isnull().any().any()

msno.matrix(df)

df.replace({' ': np.nan}, inplace=True)

df.isnull().any().any()

msno.matrix(df)

msno.bar(df)

df.columns[df.isnull().any()].tolist()

df.describe()

#Select specific row index

df.loc[[0]]

#Select specific row indices
df.loc[30:33]

#Excluding Specific Row indices
df.drop([0,24,51], axis=0).head()

#Excluding Specific Range Row indices
df.drop(df.index[1:5], axis=0).head(10)

# Subsetting based on offset from top (bottom)
df[100:].head() #df.tail(-100) )

#Get values for crime
df.apoyo.values

df['apoyo'].values

df.apoyo.unique()

df.apoyo.value_counts()

#Get the number of unique values for each column
df.agg(['count', 'size', 'nunique'])

#An agg within a groupby. Andstack at the end.
df.groupby('apoyo').agg(['count', 'size', 'nunique']).stack()

df.groupby('apoyo').agg(['count', 'size', 'nunique'])

df_sample = df.sample(frac=0.05, random_state=1)
df_sample.head()

df.shape

df_sample.shape

#Data Transform
#Drop Rows with missing count
df_dropped = df.dropna(subset=['prep_deriv'])
df_dropped.head()

df_dropped.shape

#Copy of df
df_copy = df.copy()
df_copy.head()

df_copy.shape

#Fill Missing count values with mean count
#ffill() and bfill() functions copy forward the data from the previous row (forward fill) or copy the value from the next row (backward fill)
df_dropped['ventas'].dtype

df_dropped['ventas'].mean()

df_copy['ventas'].fillna(value=np.round(df['ventas'].mean(),decimals=0), inplace=True)

df_copy.agg(['count', 'size', 'nunique'])

#Handling Categorical Data
list(df['tipoact'].unique())

"""
4 Actividades agrícolas
5 Actividades de cría y explotación de animales
6 Actividades de recolección
7 Reforestación y tala de árboles
8 Actividades de caza y captura de animales
9 Actividades de pesca
"""
df['tipoact'].replace({4:"agrícolas", 
                       5:"animales",
                       7:"recolección", 
                       6:"tala", 
                       9:"caza", 
                       8:"pesca"}, inplace=True)

list(df['tipoact'].unique())

#Create a dictionary

keys = list(df['tipoact'].unique())
vals = range(1,8)
act = dict(zip(keys, vals))
act

df_copy['tipoact_cat'] = df['tipoact'].map(act)
df_copy.head()

list(df_copy['tipoact_cat'].unique())

#Data Summarization
#Preparing a compact representation of raw data at hand

#Aggregation of data using different statistical, mathematical, and other methods. Summarization is helpful for visualization, compressing raw data, and better understanding of its attributes.
df_copy['ventas'].mean()

df_copy['ventas'][df_copy['tipoact'] == 6]

df_copy['ventas'][df_copy['tipoact_cat'] == 6].mean()

df_copy.groupby(["tipoact_cat", "cose_cria", "prep_deriv", "otro_pago"]).count()

df_copy.groupby(["tipoact_cat", "cose_cria", "prep_deriv", "otro_pago"]).count()

df_copy.groupby(["tipoact", "cose_cria"])[["prep_deriv", "otro_pago"]].count()

df_copy.tipoact

df_sample = df.sample(frac=0.05, random_state=1)
df_sample.head()

# variant-1: multiple aggregations on single attribute
df_sample.groupby(["tipoact", "cose_cria"])[["prep_deriv", "otro_pago"]].agg([np.sum, np.mean,
                                                              np.count_nonzero])

# variant-2: different aggregation functions for each attribute 

df_sample.groupby(["tipoact", "cose_cria"]).agg({'ventas':np.mean,'otro_pago':np.max})

# Commented out IPython magic to ensure Python compatibility.
#Data Visualization
#Subplots by Hand. The most basic method of creating an axes is to use the plt.axes function
# %matplotlib inline
import matplotlib.pyplot as plt
plt.style.use('seaborn-white')

ax1 = plt.axes()  # standard axes
ax2 = plt.axes([0.65, 0.65, 0.2, 0.2])

#The equivalent of this command within the object-oriented interface is fig.add_axes()

fig = plt.figure()
ax1 = fig.add_axes([0.1, 0.5, 0.8, 0.4],
                   xticklabels=[], ylim=(-1.2, 1.2))
ax2 = fig.add_axes([0.1, 0.1, 0.8, 0.4],
                   ylim=(-1.2, 1.2))

x = np.linspace(0, 10)
ax1.plot(np.sin(x))
ax2.plot(np.cos(x))

# The lowest level of these is plt.subplot(), which creates a single subplot within a grid
for i in range(1, 7):
    plt.subplot(2, 3, i)
    plt.text(0.5, 0.5, str((2, 3, i)),
             fontsize=18, ha='center')

# plt.subplots_adjust can be used to adjust the spacing between these plots
fig = plt.figure()
fig.subplots_adjust(hspace=0.4, wspace=0.4)
for i in range(1, 7):
    ax = fig.add_subplot(2, 3, i)
    ax.text(0.5, 0.5, str((2, 3, i)),
           fontsize=18, ha='center')

fig, ax = plt.subplots(2, 3, sharex='col', sharey='row')

# axes are in a two-dimensional array, indexed by [row, col]
for i in range(2):
    for j in range(3):
        ax[i, j].text(0.5, 0.5, str((i, j)),
                      fontsize=18, ha='center')
fig

# Create some normally distributed data
mean = [0, 0]
cov = [[1, 1], [1, 2]]
x, y = np.random.multivariate_normal(mean, cov, 3000).T

# Set up the axes with gridspec
fig = plt.figure(figsize=(6, 6))
grid = plt.GridSpec(4, 4, hspace=0.2, wspace=0.2)
main_ax = fig.add_subplot(grid[:-1, 1:])
y_hist = fig.add_subplot(grid[:-1, 0], xticklabels=[], sharey=main_ax)
x_hist = fig.add_subplot(grid[-1, 1:], yticklabels=[], sharex=main_ax)

# scatter points on the main axes
main_ax.plot(x, y, 'ok', markersize=3, alpha=0.2)

# histogram on the attached axes
x_hist.hist(x, 40, histtype='stepfilled',
            orientation='vertical', color='gray')
x_hist.invert_yaxis()

y_hist.hist(y, 40, histtype='stepfilled',
            orientation='horizontal', color='gray')
y_hist.invert_xaxis()

#Scatter plots
#Variables able to be highly correlated. To confirm or validate our hypothesis.
#figure.savefig('.../.jpeg')
#df_sample['ventas'] = dropna()

df_sample['ventas'] = df_sample['ventas'].astype('int64')
df_sample['tipoact'].replace({"agrícolas":4, 
                       "animales":5,
                       "recolección":7, 
                       "tala":6, 
                       "caza":9, 
                       "pesca":8}, inplace=True)
df_sample['tipoact'] = df_sample['tipoact'].astype('int64')
df_sample.plot(kind='scatter',x='ventas',y='tipoact')

#Histograms
#Plotting histograms is a great way to visualize the distribution of a numerical variable. Plotting a histogram is a method to understand the most frequent ranges (or bins as they are called) in which the variable lies. One can also check whether the variable is normally distributed or skewed on one side.

plt.hist(df_sample['tipoact'])
plt.xlabel('tipoact')
plt.ylabel('Frequency')
plt.title('Frequency of tipoact')

plt.hist(df_sample['ventas'])
plt.xlabel('ventas')
plt.ylabel('Frequency')
plt.title('Frequency of ventas')

#Boxplots
"""
Boxplots are another way to understand the distribution of a numerical variable. It specifies something called quartiles.

If the numbers in a distribution with 100 numbers are arranged in an increasing order;

the 1st quartile will occupy the 25th position,
the 3rd quartile will occupy the 75th position, and so on.
The median will be the average of the 50th and 51st terms.
Median is the middle term when the numbers in the distribution are arranged in the increasing order.
Mode is the one that occurs with the maximum frequency,
while mean is the sum of all the numbers divided by their total count."""
#plt.boxplot(df_sample['ventas'])
plt.boxplot(df_sample['ventas'], showmeans=True, meanline=True)
plt.ylabel('ventas count')
plt.title('Box Plot of ventas count')